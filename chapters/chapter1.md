## 소개

- 동작하게 만드는 코드를 만드는 것은 그리 어려운 일이 아니다
  프로그램을 “제대로” 만드는 것은 어렵다
- 제대로 된 소프트웨어
  - 적은 인력으로 새로운 기능을 추가하거나 유지보수할 수 있음
  - 변경은 단순해지고 빠르게 반영 가능
  - 결함은 적어지고 잦아든다
  - 최소한의 노력으로 기능과 유연성을 최대화할 수 있음

## 설계와 아키텍처란?

### **설계와 아키텍처**

- 둘 사이에 오랫동안 많은 혼란
- 작가는 **아무런 차이가 없다**고 주장
- **아키텍처:** 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킴
  **설계:** 저수준의 구조 또는 결정사항 등을 의미할 때가 많음
  → 실제로 하는 일을 보면 이러한 구분은 무의미함
- 새로운 집을 설계하는 건축가가 있음
  - 이 집은 아키텍처를 가지고 있나?
    → YES
  - 이 집의 아키텍처는 무엇인가?
    → 집의 형태, 외관, 입면도, 공간, 방의 배치 등
          하지만 무수히 많은 서수준의 세부사항도 확인 가능 (콘센트, 전등 위치 등)
  ⇒ 모든 고수준의 결정사항을 지탱하는 모든 세부사항을 자세하게 확인할 수 있음
  저수준의 세부사항 + 고수준의 결정사항 = 집의 전체 설계의 구성요소
- 소프트웨어 설계도 마찬가지
  - 저수준 세부사항 + 고수준의 구조 = 소프트웨어 전체 설계의 구성요소
  - 둘은 단절 없이 이어진 직물과 같음 → 이를 통해 대상 시스템의 구조를 정의함
  - 개별로는 존재할 수 없고 둘을 구분 짓는 경계는 뚜렷하지 않음
    고수준 → 저수준으로 향하는 **의사결정의 연속성**만이 존재

### 목표는?

- **좋은 소프트웨어 설계의 목표**
  → 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화
- **좋은 설계:** 비용이 낮을 뿐만 아니라 시스템의 수명이 다할 때까지 낮게 유지하는 것
  **나쁜 설계:** 새로운 기능을 출시할 때마다 비용이 증가하는 것

### 사례 연구

- 새로운 기능을 출시할 때마다 개발자의 수는 지속적으로 증가했지만
  코드 생산성은 한 곳으로 수렴
  코드 라인당 비용이 증가
  ⇒ 이 추세로는 오래갈 수 없음, 사업 모델의 수익을 고갈 시키며 성장을 멈추거나 망하게 함
- **엉망진창이 되어 가는 신호**
  - 코드와 설계의 구조를 깔끔하게 만들려는 생각을 전혀 하지 않으면 생산성이 계속 떨어짐
  - 개발자들의 노력의 가치가 보잘 것 없게 됨
- **경영자의 시각**
  - 월별 인건비가 계속해서 증가함
  - 하지만 많은 돈을 들여도 얻은게 거의 없음
- **무엇이 잘못되었나?**
  - 이솝의 **토끼와 거북이**
    - “느려도 꾸준하면 이긴다”
    - “발 빠른 자가 경주에 이기는 것도 아니며, 힘센 자가 싸움에서 이기는 것도 아니다”
    - “급할 수록 돌아가라”
  - 훌륭하고 깔끔하게 잘 설계된 코드가 중요함
    코드는 나중에 정리, 시장 출시가 먼저 ❌
    → **WHY?**
    이전에 작성한 코드로 돌아가 정리하는 일은 일어나지 않는데, 바로 다음에 만들어야 할 새로운 기능이 기다리고 있고, 다음 기능, 또 다음 기능, 또 다음 기능이 계속 기다리고 있기 때문이다.
  - 엉망진창인 코드가 쌓이면 → 생산성은 낮아지고 → 코드가 엉망이 되는 추세는 멈추지 않음 → 생산성 0에 수렴
  - 지저분한 코드를 작성하면 단기간에는 빠르게 갈 수 있고, 장기적으로 볼 때만 생산성이 낮아진다 ❌
    → 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다
  - 빨리 가는 유일한 방법은 제대로 가는 것
    → 경영자의 딜레마에 대한 해답
    → 개발자로 하여금 토끼처럼 과신하려는 믿음을 버리고, 만들어 낸 엉망진창인 코드를 개발자가 책
    임지도록 하는 것뿐이다
  - 자신을 과신한다면 재설계해도 똑같음

### 결론

- **어떤 경우라도 개발 조직이 할 수 있는 최고의 선택지:**
  - 조직에 스며든 과신을 인지 및 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것
- **좋은 소프트웨어 아키텍처가 무엇인지 알아야함!**
